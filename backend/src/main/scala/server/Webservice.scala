package server

import akka.actor.ActorSystem
import akka.http.scaladsl.server.Directives
import wvlet.log._

import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
import spray.json._

import scala.util.Success
import akka.http.scaladsl.model.StatusCodes
import services.UserService

import scala.util.Failure

trait JsonSupport extends SprayJsonSupport with DefaultJsonProtocol {
  implicit val tokenRequestFormat          = jsonFormat2(TokenRequest)
  implicit val insertOrUpdateUserReqFormat = jsonFormat3(InsertOrUpdateUserReq)
}

final case class TokenRequest(userId: String, userSecret: String)
final case class InsertOrUpdateUserReq(id: String, name: String, secret: String)

class Webservice(implicit system: ActorSystem) extends Directives with LogSupport with JsonSupport {
  Logger.setDefaultLogLevel(LogLevel.DEBUG)
  val manager = akka.actor.typed.ActorSystem(GamesManager(), s"scrable-game-manager")

  def route =
    get {
      pathSingleSlash {
        getFromResource("web/index.html")
      } ~
        // Scala-JS puts them in the root of the resource directory per default,
        // so that's where we pick them up
        path("frontend-fastopt.js.map")(getFromResource("frontend-fastopt.js.map")) ~
        path("frontend-fastopt.js")(getFromResource("frontend-fastopt.js")) ~
        path("frontend-opt.js")(getFromResource("frontend-opt.js")) ~
        path("room" / shared.Room.ID_REGEX)(_ => getFromResource("web/index.html")) ~
        path("user")(getFromResource("web/index.html")) ~
        path("api" / "users" / Remaining)(id =>
          onComplete(UserService.getUserById(id)) {
            case Failure(exception) => complete(StatusCodes.BadRequest, exception.getMessage)
            case Success(value)     => complete(StatusCodes.OK, value.toString)
          }
        ) ~
        path("ws" / "room" / shared.Room.ID_REGEX) { roomId =>
          // TODO: Secure WebSocket connection: https://devcenter.heroku.com/articles/websocket-security
          debug(s"Connecting to room $roomId")
          // TODO: Should be with token generated by user first
          parameter("token") { token =>
            onComplete(UserService.getUserWithToken(token)) {
              case Success(user) =>
                // https://github.com/playframework/play-samples/tree/2.8.x/play-java-websocket-example/app
                // https://discuss.lightbend.com/t/akka-typed-with-akka-http-ws/4800
                // https://medium.com/@nnnsadeh/building-a-reactive-distributed-messaging-server-in-scala-and-akka-with-websockets-c70440c494e3
                extractWebSocketUpgrade { upgrade =>
                  val player           = shared.Player(user.id, user.name)
                  val (sink, source, actor)   = PlayerSession.getSinkAndSource(player)
                  manager ! SklableManagerMessage.AddUserToRoom(actor, roomId)
                  complete(upgrade.handleMessagesWithSinkSource(sink, source))
                }
              case Failure(exception) => complete(StatusCodes.NetworkAuthenticationRequired, exception.getMessage)
            }
          }
        }
    } ~
        post {
          path("api" / "users") {
            entity(as[InsertOrUpdateUserReq]) { u =>
              onComplete(UserService.insertOrUpdateUser(u.id, u.name, u.secret)) {
                case Failure(exception) => complete(StatusCodes.BadRequest, exception.getMessage)
                case Success(value)     => complete(StatusCodes.OK, value.toString)
              }
            }

          } ~
            path("api" / "get_token") {
              entity(as[TokenRequest]) { tr =>
                onComplete(UserService.getToken(tr.userId, tr.userSecret)) {
                  case Success(token)     => complete(StatusCodes.OK, token)
                  case Failure(throwable) => complete(StatusCodes.BadRequest, throwable.getMessage)
                }
              }
            }
        } ~
        getFromResourceDirectory("web")
}
